name: Generate Duck Scale Image

on:
  workflow_dispatch:
    inputs:
      description:
        description: 'Duck scale theme/description'
        required: true
        type: string
      user:
        description: 'User who requested the duck scale'
        required: false
        default: 'unknown'
        type: string

jobs:
  generate-duck-scale:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process input (text or image URL)
        id: process
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          RAW_DESCRIPTION: ${{ inputs.description }}
        run: |
          # Strip common prefixes like "duck scale it:", "duck scale a", "duck scale"
          CLEAN=$(echo "$RAW_DESCRIPTION" | sed -E 's/^duck scale (it:?|a|an|the|me)?\s*//i' | xargs)
          echo "Cleaned input: $CLEAN"

          # Check if input looks like a URL - if so, try to download and verify it's an image
          IS_IMAGE="false"
          if echo "$CLEAN" | grep -qiE '^https?://'; then
            echo "Detected URL, attempting to download..."

            # Download the file
            if curl -sS -L -f -o reference_image_download "$CLEAN"; then
              echo "Download successful, checking file type..."

              # Check if it's actually an image using file command
              FILE_TYPE=$(file -b --mime-type reference_image_download)
              echo "File type: $FILE_TYPE"

              if echo "$FILE_TYPE" | grep -q '^image/'; then
                echo "Confirmed: file is an image"
                mv reference_image_download reference_image.png
                IS_IMAGE="true"
              else
                echo "File is not an image, treating input as text description"
                rm -f reference_image_download
              fi
            else
              echo "Download failed, treating input as text description"
            fi
          fi

          if [ "$IS_IMAGE" = "true" ]; then
            echo "is_image_url=true" >> $GITHUB_OUTPUT

            # Use vision API to get a description of the image
            VISION_RESPONSE=$(curl -sS -X POST "https://api.openai.com/v1/chat/completions" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$(jq -n \
                --arg img "$(base64 -w0 reference_image.png 2>/dev/null || base64 -i reference_image.png)" \
                '{
                  model: "gpt-4o",
                  messages: [
                    {
                      role: "user",
                      content: [
                        {
                          type: "text",
                          text: "Describe this image in 2-5 words for use as a label. Be concise. Examples: \"orange tabby cat\", \"red sports car\", \"chocolate birthday cake\". Just output the label, nothing else."
                        },
                        {
                          type: "image_url",
                          image_url: {
                            url: ("data:image/png;base64," + $img)
                          }
                        }
                      ]
                    }
                  ],
                  max_tokens: 50
                }')")

            DESCRIPTION=$(echo "$VISION_RESPONSE" | jq -r '.choices[0].message.content // empty')
            if [ -z "$DESCRIPTION" ]; then
              echo "Failed to get description from vision API"
              echo "Response: $VISION_RESPONSE"
              DESCRIPTION="custom image"
            fi
            echo "Vision API description: $DESCRIPTION"
          else
            echo "is_image_url=false" >> $GITHUB_OUTPUT
            DESCRIPTION="$CLEAN"
          fi

          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT

      - name: Edit Image with OpenAI
        id: generate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DESCRIPTION: ${{ steps.process.outputs.description }}
          IS_IMAGE_URL: ${{ steps.process.outputs.is_image_url }}
          USER: ${{ inputs.user }}
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          # Sanitize description and user for filename (lowercase, replace spaces/special chars with dashes)
          SAFE_DESC=$(echo "$DESCRIPTION" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-30)
          SAFE_USER=$(echo "$USER" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')
          FILENAME="${SAFE_DESC}-${SAFE_USER}-${TIMESTAMP}.png"

          # Ensure output directory exists
          mkdir -p duck-scales

          # Read prompt template from file and substitute description
          # (avoids YAML parsing issues with colons in heredoc content)
          PROMPT=$(sed "s|__DESCRIPTION__|${DESCRIPTION}|g" prompt_template.txt)

          # If we have a reference image, add instruction to match its appearance
          if [ "$IS_IMAGE_URL" = "true" ]; then
            PROMPT="$PROMPT IMPORTANT - A reference image is provided. The replacement inflatable float should closely match the appearance, colors, and style of the subject shown in the reference image."
          fi

          echo "Editing duck scale with description: $DESCRIPTION"
          echo "Has reference image: $IS_IMAGE_URL"

          # Build the curl command - conditionally include reference image
          if [ "$IS_IMAGE_URL" = "true" ] && [ -f "reference_image.png" ]; then
            echo "Including reference image in API call"
            # Use image[] array syntax to pass multiple images
            RESPONSE=$(curl -sS --fail-with-body -X POST "https://api.openai.com/v1/images/edits" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -F "model=gpt-image-1" \
              -F "image[]=@duck_scale.jpeg" \
              -F "image[]=@reference_image.png" \
              -F "mask=@duck_scale_mask.png" \
              --form-string "prompt=$PROMPT" \
              -F "input_fidelity=high" \
              -F "quality=high" \
              -F "size=1024x1024" \
              -F "user=$SAFE_USER")
          else
            RESPONSE=$(curl -sS --fail-with-body -X POST "https://api.openai.com/v1/images/edits" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -F "model=gpt-image-1" \
              -F "image=@duck_scale.jpeg" \
              -F "mask=@duck_scale_mask.png" \
              --form-string "prompt=$PROMPT" \
              -F "input_fidelity=high" \
              -F "quality=high" \
              -F "size=1024x1024" \
              -F "user=$SAFE_USER")
          fi

          echo "API Response received"

          # Check for errors
          ERROR=$(echo "$RESPONSE" | jq -r '.error.message // empty')
          if [ -n "$ERROR" ]; then
            echo "Error from OpenAI API: $ERROR"
            echo "Full response: $RESPONSE"
            exit 1
          fi

          # Extract base64 image data
          IMAGE_B64=$(echo "$RESPONSE" | jq -r '.data[0].b64_json // empty')

          if [ -n "$IMAGE_B64" ] && [ "$IMAGE_B64" != "null" ]; then
            echo "$IMAGE_B64" | base64 -d > "duck-scales/$FILENAME"
          else
            echo "No image data found in response"
            echo "Full response: $RESPONSE"
            exit 1
          fi

          echo "Image saved to duck-scales/$FILENAME"
          echo "filename=$FILENAME" >> $GITHUB_OUTPUT

      - name: Commit and Push Image
        env:
          DESCRIPTION: ${{ steps.process.outputs.description }}
          USER: ${{ inputs.user }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add duck-scales/
          git commit -m "Add duck scale image: ${{ steps.generate.outputs.filename }}

          Requested by: ${USER}
          Description: ${DESCRIPTION}"
          git push

      - name: Get Image URL
        id: image_url
        run: |
          FILENAME="${{ steps.generate.outputs.filename }}"
          IMAGE_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/duck-scales/${FILENAME}"
          echo "url=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "Image URL: $IMAGE_URL"

      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          IMAGE_URL: ${{ steps.image_url.outputs.url }}
          USER: ${{ inputs.user }}
          DESCRIPTION: ${{ steps.process.outputs.description }}
        run: |
          # Build JSON payload for Slack workflow webhook
          SLACK_PAYLOAD=$(jq -n \
            --arg url "$IMAGE_URL" \
            --arg user "$USER" \
            --arg desc "$DESCRIPTION" \
            '{duck_scale_url: $url, requested_by_user: $user, duck_scale_description: $desc}')

          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$SLACK_PAYLOAD"

          echo "Slack workflow webhook called with: $SLACK_PAYLOAD"
